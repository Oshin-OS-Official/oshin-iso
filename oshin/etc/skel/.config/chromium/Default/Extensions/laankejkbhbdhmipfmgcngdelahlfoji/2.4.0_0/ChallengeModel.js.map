{"version":3,"file":"ChallengeModel.js","sources":["../src/components/Challenge/ChallengeModel.js"],"sourcesContent":["import Logger from '~/core/Logger'\nimport API from '~/core/CoreAPI'\n\n/**\n * Alias for Logger.log(). Prepends class name to funcName.\n *\n * @param originator The name of the instance to prepend to the log message\n * @param funcName The name of the function generating the log message\n * @param message The message to log\n * @param payload Data object\n * @param level Log level (ERROR, WARN, INFO, DEBUG)\n */\nvar log = function (originator, funcName, message, payload, level) {\n  Logger.log(originator + '.' + funcName, message, payload, level)\n}\n\nexport default class ChallengeModel {\n  bp = null\n  defaultText = null\n  keyCounter = 0\n  minLength = 0\n  required = null\n  text = null\n\n  constructor() {\n    var bpArray = ['s', 'b', 'p', 'a', 'y']\n    this.bp =\n      '_' +\n      bpArray[1] +\n      bpArray[4] +\n      bpArray[2] +\n      bpArray[3] +\n      bpArray[0] +\n      bpArray[0]\n\n    this.addListeners()\n  }\n\n  /**\n   * Adds message listeners\n   */\n  addListeners() {\n    var self = this\n\n    API.PubSub.listen('ChallengeModel.text.set', function (message, payload) {\n      self.text = payload.text\n    })\n  }\n\n  /**\n   * Loads challenge\n   *\n   * @param onLoaded Function to call once loaded\n   */\n  load(onLoaded) {\n    this.defaultText = API.Chrome.Translation.get('defaultChallengeText')\n    this.minLength = decodeURIComponent(this.defaultText).length\n    this.required = API.Settings.get('challengeRequired')\n\n    this.clearProductivityBypass()\n\n    if (typeof onLoaded === 'function') {\n      onLoaded()\n    }\n  }\n\n  /**\n   * Sets the challenge to be required or not\n   *\n   * @param required\n   */\n  setRequired(required) {\n    API.Analytics.event('TOGGLE_SETTINGS_CHALLENGE_REQUIRED', { required })\n\n    API.Settings.set({ challengeRequired: required })\n\n    this.required = required\n  }\n\n  /**\n   * Checks whether challenge is required\n   *\n   * @returns {boolean}\n   */\n  isRequired() {\n    return this.required === true\n  }\n\n  /**\n   * Gets challenge text. If it hasn't been set, or if the stored text\n   * is less than the min length (which indicates it has been tampered\n   * with in an effort to bypass the challenge), then the default text\n   * is used.\n   */\n  getText(useDefault) {\n    if (useDefault) {\n      this.text = this.defaultText\n    } else if (!this.text) {\n      this.text = API.Settings.get('challengeText')\n      this.text =\n        typeof this.text === 'string'\n          ? decodeURIComponent(this.text)\n          : this.defaultText\n\n      if (this.text.length < this.minLength) {\n        this.text = this.defaultText\n      }\n    }\n\n    return this.text\n  }\n\n  /**\n   * Sets the challenge text\n   *\n   * @param newText The new challenge text\n   * @returns {boolean}\n   */\n  setText(newText) {\n    /* Make sure the challenge text is long enough */\n    if (!this.isLongEnough(newText)) {\n      alert(\n        API.Chrome.Translation.get(\n          'challengeTextTooShort',\n          this.minLength.toString(),\n        ),\n      )\n      return false\n    }\n\n    /* If not enough unique letters are used, the text may be someone trying to cheat by entering\n     * a repeating string of the same letter or few letters. */\n    if (!this.isUniqueEnough(newText)) {\n      alert(API.Chrome.Translation.get('notEnoughVariation'))\n      return false\n    }\n\n    /* Strip line breaks, tabs, multiple spaces, and MS Word special chars,\n     * which can make the challenge overly difficult or impossible */\n    newText = newText.split('\\n').join(' ')\n    newText = newText.split('\\r').join(' ')\n    newText = newText.split('\\t').join(' ')\n    newText = newText.replace(/ +(?= )/g, '')\n    newText = API.Utils.sanitizeMSWordChars(newText)\n\n    API.Settings.set(\n      { challengeText: encodeURIComponent(newText) },\n      function () {\n        API.PubSub.publish('ChallengeModel.text.set', { text: newText })\n\n        alert(API.Chrome.Translation.get('challengeTextSet'))\n      },\n    )\n  }\n\n  /**\n   * Resets the challenge text to the default text\n   */\n  resetText() {\n    this.setText(this.defaultText)\n  }\n\n  /**\n   * Sets the productivity bypass\n   */\n  setProductivityBypass() {\n    log(this.originator, 'setProductivityBypass', 'Setting productivity bypass')\n\n    API.Settings.set({ productivityBypass: true })\n  }\n\n  /**\n   * Clears the productivity bypass\n   */\n  clearProductivityBypass() {\n    log(\n      this.originator,\n      'clearProductivityBypass',\n      'Clearing productivity bypass',\n    )\n\n    API.Settings.remove('productivityBypass')\n  }\n\n  /**\n   * Checks whether the productivity bypass is active\n   *\n   * @returns {boolean}\n   */\n  isProductivityBypassActive() {\n    return API.Settings.get('productivityBypass') === true\n  }\n\n  /**\n   * Checks whether the text input matches the number of keys pressed.\n   * This catches cut-and-paste trickery\n   *\n   * @param inputText The typed text\n   * @returns {boolean}\n   */\n  isRightLength(inputText) {\n    return this.keyCounter === inputText.length\n  }\n\n  /**\n   * Checks whether the challenge text is long enough\n   *\n   * @param text The text to check\n   * @returns {boolean}\n   */\n  isLongEnough(text) {\n    return text.length >= this.minLength\n  }\n\n  /**\n   * Checks whether the challenge text is unique enough\n   *\n   * @param text The text to check\n   * @returns {boolean}\n   */\n  isUniqueEnough(text) {\n    var usedLetters = []\n\n    /* Check the number of unique letters used */\n    for (var i = 0; i < text.length; i++) {\n      var thisLetter = text.charAt(i)\n\n      if (!usedLetters.inArray(thisLetter)) {\n        usedLetters.push(thisLetter)\n      }\n    }\n\n    return usedLetters.length >= 5\n  }\n\n  /**\n   * Checks whether typed text matches challenge text so far\n   *\n   * @param inputText The typed text\n   * @param offset The offset to use when checking\n   * @returns {boolean}\n   */\n  isCorrect(inputText, offset) {\n    var sourceSnippet = this.text.substring(\n      0,\n      Math.max(inputText.length + offset, 0),\n    )\n    var bpSnippet = this.bp.substring(0, Math.max(inputText.length + offset, 0))\n\n    var offsetedInputText = inputText.substring(\n      0,\n      Math.max(inputText.length + offset, 0),\n    )\n\n    return (\n      offsetedInputText === sourceSnippet || offsetedInputText === bpSnippet\n    )\n  }\n\n  /**\n   * Checks whether the challenge was successfully completed\n   *\n   * @param inputText The typed text\n   * @returns {boolean}\n   */\n  isComplete(inputText) {\n    return inputText.length === this.text.length || inputText === this.bp\n  }\n\n  getKeyCounter() {\n    return this.keyCounter\n  }\n\n  updateKeyCounter(value) {\n    this.keyCounter = value\n  }\n\n  resetKeyCounter() {\n    this.keyCounter = 0\n  }\n}\n"],"names":["log","originator","funcName","message","payload","level","Logger","ChallengeModel","__publicField","bpArray","self","API","onLoaded","required","useDefault","newText","inputText","text","usedLetters","i","thisLetter","offset","sourceSnippet","bpSnippet","offsetedInputText","value"],"mappings":"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"}